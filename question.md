以下是我们在 EcoGuardian 2.0 系统中发现并修复的所有关键问题清单：

### 1. 基础逻辑与架构层

*   **问题：冷启动死锁 (Cold Start Deadlock)**
    *   **现象**：程序刚启动时，机器人看到火也不动。
    *   **原因**：初始 `PREDICTION_PENALTY` (2000) 过高，导致计算出的竞价成本 (Cost) 超过了拒绝阈值 (Threshold)，所有任务都被系统“拒单”。
    *   **修复**：在 `main()` 初始化阶段强制将 `PREDICTION_PENALTY` 设为 **500.0**，并在 `settings.py` 中提高拒绝阈值至 **5000.0**，扩大数值运作空间。

*   **问题：变量作用域失效 (Scope Issue)**
    *   **现象**：修改了 `main.py` 的参数，但机器人行为没变化。
    *   **原因**：Python 的 `from settings import *` 机制导致 `robot.py` 持有的是旧常量的副本，感知不到 `main.py` 中全局变量的变化。
    *   **修复**：修改 `robot.calculate_bid()` 方法，**增加 `penalty` 参数**，实现从 `main.py` 到 `Robot` 实例的动态透传。

*   **问题：语法错误 (Syntax Error)**
    *   **现象**：`SyntaxError: name assigned to before global declaration`。
    *   **原因**：`global` 声明语句的位置晚于变量的使用位置。
    *   **修复**：将 `global PREDICTION_PENALTY` 移至 `main()` 函数的**第一行**。

### 2. 多智能体协作层 (Multi-Agent)

*   **问题：严重的羊群效应 (Herding Effect)**
    *   **现象**：多个机器人挤在一起去抢同一个火点，导致由于路径冲突或重复劳动而浪费资源。
    *   **原因**：
        1.  旧的任务调度算法会根据火势强制分配多个机器人 (`needed_bots > 1`)。
        2.  缺乏“互斥检测”，机器人不知道队友已经去了目标附近的格子。
    *   **修复**：
        1.  **强制单人单火**：无论火势多大，一轮调度只派一个机器人。
        2.  **社交距离 (Social Distancing)**：建立 `occupied_targets` 缓存，如果某火点周围 **2格内** 已有机器人前往，后续机器人直接跳过该火点（硬约束）。

### 3. 机器学习与优化层 (ML & GA)

*   **问题：梯度爆炸与训练震荡 (Gradient Explosion)**
    *   **现象**：ML 权重忽大忽小，难以收敛。
    *   **原因**：特征数值差异过大（例如：距离特征是 0~60，而电池特征是 0~1）。大数值特征主导了梯度下降，导致模型“步子迈太大”。
    *   **修复**：在 `main.py` 中实施**特征归一化 (Feature Normalization)**，将距离、火势、障碍物密度全部映射到 **0.0 ~ 1.0** 区间。

*   **问题：白板起步 (Tabula Rasa) 导致的错误认知**
    *   **现象**：ML 训练出违反常识的权重（例如：距离权重为负，认为“离得越近越容易失败”）。
    *   **原因**：模型初始权重全为 0，早期的随机成败让模型学到了错误的因果关系（“第一印象偏差”）。
    *   **修复**：**启发式初始化 (Heuristic Initialization)**。在 `Predictor` 初始化时人工植入“常识”（如：距离权重设为 +0.5，障碍权重设为 -0.5），让模型在正确的基础上微调，而不是从零瞎猜。

*   **问题：学习机制过于简单**
    *   **修复**：
        1.  引入 **学习率衰减 (LR Decay)**，随着训练次数增加降低步长，保证后期稳定。
        2.  引入 **权重剪裁 (Weight Clipping)**，防止权重数值无限膨胀。
        3.  加强 **负反馈力度**，让遗传算法（GA）对扎堆行为的惩罚从 1.0 提升至 15.0。
