Directory structure:
â””â”€â”€ Ecoguardian/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ main.py
    â”œâ”€â”€ question.md
    â”œâ”€â”€ requirements.txt
    â”œâ”€â”€ æŠ€æœ¯æ–‡æ¡£.md
    â”œâ”€â”€ agents/
    â”‚   â”œâ”€â”€ base_agent.py
    â”‚   â”œâ”€â”€ drone.py
    â”‚   â””â”€â”€ robot.py
    â”œâ”€â”€ configs/
    â”‚   â””â”€â”€ settings.py
    â””â”€â”€ core/
        â”œâ”€â”€ genetic_optimizer.py
        â”œâ”€â”€ grid_map.py
        â”œâ”€â”€ pathfinding.py
        â””â”€â”€ predictor.py

================================================
FILE: README.md
================================================
# ğŸŒ² EcoGuardian 2.0 - æ™ºèƒ½æ£®æ—æ¶ˆé˜²å¤šæ™ºèƒ½ä½“ä»¿çœŸç³»ç»Ÿ

**EcoGuardian 2.0** æ˜¯ä¸€ä¸ªåŸºäº Python (Pygame + NumPy) å¼€å‘çš„é«˜æ€§èƒ½å¤šæ™ºèƒ½ä½“æ£®æ—æ¶ˆé˜²ä»¿çœŸå¹³å°ã€‚è¯¥ç³»ç»Ÿæ¨¡æ‹Ÿäº†å¤æ‚çš„ç«ç¾è”“å»¶åŠ¨åŠ›å­¦ï¼Œå¹¶é›†æˆ **UGV (åœ°é¢æœºå™¨äºº)**ã€**UAV (ç©ºä¸­æ— äººæœº)** å’Œ **SupportBot (è¡¥ç»™æœºå™¨äºº)** ä¸‰ç§å¼‚æ„æ™ºèƒ½ä½“ï¼Œé€šè¿‡ **åœ¨çº¿æœºå™¨å­¦ä¹  (Online ML)**ã€**é—ä¼ ç®—æ³• (GA)** å’Œ **è‡ªé€‚åº” A* è·¯å¾„è§„åˆ’** å®ç°é«˜æ•ˆçš„åˆ†å¸ƒå¼ååŒç­ç«ã€‚

---

## âœ¨ æ ¸å¿ƒç‰¹æ€§ (Key Features)

### 1. ğŸ”¥ é«˜ä¿çœŸç‰©ç†ç¯å¢ƒ (Physics Engine)

* **å‘é‡åŒ–å…ƒèƒè‡ªåŠ¨æœº**ï¼šåŸºäº NumPy çš„çŸ©é˜µè¿ç®—å®ç°é«˜æ€§èƒ½å¹¶è¡Œä»¿çœŸï¼Œæ”¯æŒ 60FPS æµç•…è¿è¡Œã€‚
* **å¤šç»´ç¯å¢ƒæ‹Ÿåˆ**ï¼šåŒ…å«åŠ¨æ€é£åœºã€å¹²ç‡¥åº¦ç´¯ç§¯ã€ç‡ƒæ–™è¡°å‡åŠ **è‡ªç‡ƒ (Spontaneous Ignition)** æœºåˆ¶ã€‚
* **ç¨€ç–çŸ©é˜µä¼˜åŒ–**ï¼šåˆ©ç”¨ `np.argwhere` ç¨€ç–ç´¢å¼•åŠ é€Ÿç«åŠ¿è”“å»¶è®¡ç®—ï¼Œé¿å…å…¨å›¾éå†ã€‚

### 2. ğŸ¤– å¼‚æ„å¤šæ™ºèƒ½ä½“ååŒ (Heterogeneous Agents)

* **ğŸš ä¾¦å¯Ÿæ— äººæœº (UAV)**ï¼šé‡‡ç”¨ **è’™ç‰¹å¡æ´›éšæœºé‡‡æ ·** ç­–ç•¥ï¼Œåœ¨é«˜ç©ºæ‰§è¡Œ  å¹¿åŸŸæ‰«æï¼Œæ„å»ºå…¨å±€æ„ŸçŸ¥â€œæˆ˜äº‰è¿·é›¾â€ã€‚
* **ğŸšœ ç­ç«æœºå™¨äºº (UGV)**ï¼š
* åŸºäº **FSM (æœ‰é™çŠ¶æ€æœº)** ç®¡ç† IDLE, MOVING, RETURNING, STRANDED çŠ¶æ€ã€‚
* å…·å¤‡ **3x3 AOE å¼ºåŠ›ç­ç«** èƒ½åŠ›åŠ **è¿å‡»æ¸…ç† (Mopping Up)** ç­–ç•¥ã€‚
* é›†æˆ **Logistic Regression** æ¨¡å‹ï¼ŒåŸºäºç”µé‡ã€æ°´é‡ã€é£å‘å¯¹é½åº¦ç­‰ **6D ç‰¹å¾** è¿›è¡Œä»»åŠ¡ç«ä»·ã€‚


* **ğŸš‘ è¡¥ç»™æœºå™¨äºº (SupportBot)**ï¼š
* å…¨å›¾ç›‘æ§å‹å†›çŠ¶æ€ï¼Œä¸€æ—¦å‘ç°ææµ… (Stranded) ç«‹å³è§¦å‘æ•‘æ´ã€‚
* æ‹¥æœ‰ **2å€é€Ÿç§»åŠ¨** èƒ½åŠ›ä¸ **å¼ºåŠ›æ¨åœŸæœºæ¨¡å¼** (è‡ªåŠ¨æ¸…é™¤è·¯å¾„ä¸Šçš„ç«éšœ)ã€‚



### 3. ğŸ§  æ··åˆæ™ºèƒ½å†³ç­–æ¶æ„ (Hybrid AI)

* **å¾®è§‚å†³ç­– (Online Learning)**ï¼šUGV å†…ç½®é€»è¾‘å›å½’é¢„æµ‹å™¨ï¼Œå…·å¤‡ **å¯å‘å¼åˆå§‹åŒ– (Heuristic Init)**ã€**å­¦ä¹ ç‡è¡°å‡** åŠ **æƒé‡å‰ªè£** æœºåˆ¶ï¼Œèƒ½åœ¨ä»¿çœŸè¿è¡Œä¸­å®æ—¶ä¿®æ­£å†³ç­–æƒé‡ã€‚
* **å®è§‚ä¼˜åŒ– (Genetic Algorithm)**ï¼šåå°è¿è¡Œé—ä¼ ç®—æ³•ï¼Œé’ˆå¯¹å…¨å±€å‚æ•°ï¼ˆå¦‚ç«ä»·æƒ©ç½šç³»æ•°ã€é¿å«ŒåŠå¾„ï¼‰è¿›è¡Œæ¼”åŒ–ã€‚é‡‡ç”¨ **ç²¾è‹±ä¿ç•™ (Elitism)** ä¸ **é«˜é¢‘å˜å¼‚ (Rate=0.5)** ç­–ç•¥ï¼ŒåŠ¨æ€é€‚åº”ç¯å¢ƒå˜åŒ–ã€‚
* **è‡ªé€‚åº”è·¯å¾„è§„åˆ’ (Adaptive A*)**ï¼š
* å®ç° **å»¶è¿Ÿåˆ é™¤ (Lazy Deletion)** æœºåˆ¶ä¼˜åŒ–ä¼˜å…ˆé˜Ÿåˆ—æ€§èƒ½ã€‚
* å¼•å…¥ **åŠ¨æ€ç«åœºä»£ä»· (Dynamic Fire Cost)**ï¼šæŒæ°´æ—¶è§†ç«ä¸ºé€šè·¯ (Cost=1)ï¼Œæ— æ°´æ—¶è§†ç«ä¸ºéšœç¢ (Cost=50)ã€‚



---

## ğŸ“‚ é¡¹ç›®ç»“æ„ (Structure)

```text
EcoGuardian/
â”œâ”€â”€ main.py                  # ç¨‹åºå…¥å£ä¸ä¸»å¾ªç¯
â”œâ”€â”€ configs/
â”‚   â””â”€â”€ settings.py          # å…¨å±€é…ç½® (é¢œè‰²ã€åœ°å›¾å°ºå¯¸ã€ç‰©ç†å‚æ•°)
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ grid_map.py          # ç‰©ç†å¼•æ“ (ç«åŠ¿è”“å»¶ã€å¹²ç‡¥åº¦ã€è‡ªç‡ƒ)
â”‚   â”œâ”€â”€ genetic_optimizer.py # é—ä¼ ç®—æ³•ä¼˜åŒ–å™¨ (GA)
â”‚   â””â”€â”€ pathfinding.py       # è·¯å¾„è§„åˆ’ç®—æ³• (A*)
â””â”€â”€ agents/
    â”œâ”€â”€ base_agent.py        # æ™ºèƒ½ä½“åŸºç±»
    â”œâ”€â”€ robot.py             # åœ°é¢æœºå™¨äºº (UGV) ä¸ è¡¥ç»™æœºå™¨äºº (SupportBot)
    â”œâ”€â”€ drone.py             # æ— äººæœº (UAV)
    â””â”€â”€ predictor.py         # æœºå™¨å­¦ä¹ é¢„æµ‹å™¨ (ML)

```

---

## ğŸš€ å¿«é€Ÿå¼€å§‹ (Quick Start)

### ä¾èµ–å®‰è£…

ç¡®ä¿æ‚¨çš„ç¯å¢ƒå·²å®‰è£… Python 3.8+ï¼Œå¹¶å®‰è£…ä»¥ä¸‹ä¾èµ–åº“ï¼š

```bash
pip install pygame numpy

```

### è¿è¡Œä»¿çœŸ

åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹è¿è¡Œï¼š

```bash
python main.py

```

### æ“ä½œæŒ‡å— (Controls)

* **[ç©ºæ ¼é”®]**ï¼šåœ¨é¼ æ ‡ä½ç½®éšæœºå¼•ç‡ƒç«ç‚¹ (æ¨¡æ‹Ÿäººä¸º/çªå‘ç«æƒ…)ã€‚
* **[é¼ æ ‡å·¦é”®]**ï¼šç‚¹å‡»å•å…ƒæ ¼å¯æ‰‹åŠ¨åˆ‡æ¢åœ°å½¢çŠ¶æ€ (å¦‚å»ºç«‹é˜»ç«å¢™)ã€‚
* **UI ä¾§è¾¹æ **ï¼š
* å®æ—¶æ˜¾ç¤ºå½“å‰ä»£æ•° (Gen) ä¸å¸§æ•° (Frame)ã€‚
* **ML Weights**ï¼šå®æ—¶æ»šåŠ¨çš„æœºå™¨å­¦ä¹ ç‰¹å¾æƒé‡ã€‚
* **Logs**ï¼šä»»åŠ¡åˆ†å‘æ—¥å¿—ä¸æ•‘æ´äº‹ä»¶æ—¥å¿—ã€‚



---

## ğŸ“Š ç®—æ³•ç»†èŠ‚ (Algorithm Details)

### 1. æœºå™¨å­¦ä¹ ç‰¹å¾å·¥ç¨‹ (6D Features)

UGV åœ¨ç«ä»·æ—¶ä¼šè¯„ä¼°ä»¥ä¸‹ç‰¹å¾å‘é‡ ï¼š

1. ** Proximity**ï¼šè·ç¦»æ¥è¿‘åº¦ (è¶Šè¿‘è¶Šå¥½)
2. ** Severity**ï¼šç«åŠ¿ä¸¥é‡åº¦ (ä¼˜å…ˆå¤„ç†é‡ç¾åŒº)
3. ** Battery**ï¼šå‰©ä½™ç”µé‡
4. ** Water**ï¼šå‰©ä½™æ°´é‡
5. ** Obstacle Density**ï¼šè·¯å¾„éšœç¢å¯†åº¦
6. ** Wind Alignment**ï¼šé£å‘å¯¹é½åº¦ (ä¸Šé£å£ä¼˜åŠ¿)

### 2. é—ä¼ ç®—æ³•é€‚åº”åº¦å‡½æ•° (Fitness Function)

ä¸ºäº†é˜²æ­¢ç®—æ³•æ—©ç†Ÿæ”¶æ•›ï¼Œè¯„ä¼°å‡½æ•°ç»¼åˆäº†ä»¥ä¸‹ 5 ä¸ªç»´åº¦ï¼š

*è¯¥å…¬å¼å¼ºåŠ›æƒ©ç½šæœºå™¨äººææµ…è¡Œä¸ºï¼Œå¹¶é¼“åŠ±åœ¨å‡å°‘æ‹¥æŒ¤çš„å‰æä¸‹æœ€å¤§åŒ–ç­ç«äº§å‡ºã€‚*

---

## ğŸ“· æˆªå›¾å±•ç¤º (Screenshots)

*(æ­¤å¤„å»ºè®®æ”¾ä¸‰å¼ å›¾ï¼š1. å…¨å±€è¿è¡Œå›¾ 2. æœºå™¨äººAOEç­ç«ç‰¹å†™ 3. SupportBotæ•‘æ´ç‰¹å†™)*

---

## ğŸ“ å¼€å‘æ—¥å¿— (Dev Logs)

* **2025-12-26**: é‡æ„ A* ç®—æ³•ï¼Œç§»é™¤æ˜¾å¼ Closed Setï¼Œé‡‡ç”¨ Lazy Deletion æå‡å¯»è·¯æ•ˆç‡ã€‚
* **2025-12-25**: å®Œå–„ SupportBot é€»è¾‘ï¼Œå¢åŠ åŒå€é€Ÿç§»åŠ¨ä¸è·¯å¾„è‡ªä¿æ¸…é™¤æœºåˆ¶ã€‚
* **2025-12-24**: ä¿®æ­£ Drone æ‰«æé€»è¾‘ï¼Œå°†è§†é‡èŒƒå›´æ ¡å‡†ä¸º  åŒºåŸŸã€‚
* **2025-12-23**: å¼•å…¥ GridMap åˆ†å±‚è®¾è®¡ï¼Œåˆ†ç¦»ç‡ƒæ–™å±‚ (Fuel) ä¸å¹²ç‡¥åº¦å±‚ (Dryness)ï¼ŒåŠ å…¥è‡ªç‡ƒæœºåˆ¶ã€‚

---

## ğŸ“„ License

This project is open-source and available under the [MIT License](https://www.google.com/search?q=LICENSE).


================================================
FILE: main.py
================================================
import pygame
import sys
import numpy as np
import matplotlib
import os
matplotlib.use("Agg")
import matplotlib.pyplot as plt

from configs.settings import *
from core.grid_map import GridMap
from agents.robot import Robot, SupportBot
from agents.drone import Drone
from core.predictor import EfficiencyPredictor
from core.genetic_optimizer import GeneticOptimizer
class Logger(object):
    def __init__(self, filename="simulation.log"):
        self.terminal_out = sys.stdout
        self.terminal_err = sys.stderr
        # buffering=1 å¼€å¯è¡Œç¼“å†²ï¼Œç¡®ä¿æ¯ä¸€è¡Œæ—¥å¿—éƒ½å®æ—¶å†™å…¥æ–‡ä»¶
        self.log = open(filename, "w", encoding='utf-8', buffering=1)

    def write(self, message):
        self.terminal_out.write(message)
        self.log.write(message)
        self.log.flush()

    def flush(self):
        self.terminal_out.flush()
        self.terminal_err.flush()
        self.log.flush()
def log_system_status(frame, env, robots, predictor, ga, penalty):
    w = predictor.weights
    genome = ga.get_current_genome()
    
    # [å…³é”®è¡¥å……] è·å–é—²ç½®ç»Ÿè®¡ (ä½¿ç”¨ getattr é˜²æ­¢æ—§å¯¹è±¡æ²¡æœ‰è¯¥å±æ€§æŠ¥é”™)
    # è¿™ä¸ªæ•°å­—åæ˜ äº†æœ¬ä»£æœºå™¨äººâ€œå‘å‘†â€çš„ä¸¥é‡ç¨‹åº¦ï¼Œæ•°å­—è¶Šå°è¶Šå¥½
    idle_stat = getattr(genome, 'idle_frames', 0)
    
    print(f"\n" + "="*50)
    print(f" FRAME: {frame} | GEN: {ga.generation} | INDIVIDUAL: {ga.current_idx + 1}")
    print("-" * 50)
    
    # 1. ç¯å¢ƒçŠ¶æ€
    active_fires = np.sum(env.grid == 2)
    extinguished = np.sum(env.grid == 6)
    print(f"[ENV] Active Fires: {active_fires} | Total Extinguished: {extinguished}")
    
    # 2. æœºå™¨äººå®æ—¶çŠ¶æ€
    # ç›‘æ§ Stranded æ˜¯ä¸ºäº†æ£€æŸ¥æ˜¯å¦æœ‰æœºå™¨äººå› ä¸ºè´ªå©ªæŠ¢å•è€Œæ­»åœ¨åŠè·¯
    stranded_count = sum(1 for r in robots if r.status == "STRANDED")
    idle_current = sum(1 for r in robots if r.status == "IDLE")
    print(f"[BOT] Idle: {idle_current} | Stranded: {stranded_count} | Moving: {len(robots)-idle_current-stranded_count}")
    
    # 3. é—ä¼ ç®—æ³•å‚æ•° (æ ¸å¿ƒç›‘æ§åŒº)
    # Radius: å†³å®šäº†é¿å«ŒèŒƒå›´ (è¶Šå°è¶Šæ¿€è¿›)
    # IdleSum: å†³å®šäº†é—²ç½®æƒ©ç½šåŠ›åº¦ (å¦‚æœä½ å‘ç° Radius å¾ˆå°ä½† IdleSum å¾ˆå¤§ï¼Œè¯´æ˜åœ°å›¾å¤ªå¤§äº†æˆ–è€…ç«å¤ªå°‘äº†)
    print(f"[GA ] Radius: {genome.radius} | Penalty: {penalty:.1f} | IdleSum (ç´¯è®¡é—²ç½®): {idle_stat}")
    
    # 4. æœºå™¨å­¦ä¹ æƒé‡ (MLç›‘æ§)
    # æ£€æŸ¥ Bat/Wat æ˜¯å¦æ­»å®ˆ 0.3 åº•çº¿ï¼Œæ£€æŸ¥ Sev æ˜¯å¦è¿‡ä½
    print(f"[ML ] Weights Snapshot:")
    print(f"      Prox: {w[0]:.3f} | Sev: {w[1]:.3f} | Wind: {w[5]:.3f}")
    print(f"      Bat : {w[2]:.3f} | Wat: {w[3]:.3f} | Obs : {w[4]:.3f}")
    
    # è­¦å‘Šæç¤º
    if w[2] <= 0.31 or w[3] <= 0.31:
        print("      âš ï¸  WARNING: Resource weights near floor (Risk of Stranding)")
        
    print("="*50 + "\n")

def save_weight_chart(history, frame, generation, save_dir="plots"):
    """ç”Ÿæˆå¹¶ä¿å­˜å½“å‰çš„æƒé‡è¿›åŒ–å›¾"""
    if not history: return
    
    # ç¡®ä¿ç›®å½•å­˜åœ¨
    if not os.path.exists(save_dir):
        os.makedirs(save_dir)

    # å‡†å¤‡æ•°æ®
    data_np = np.array(history)
    x_axis = np.arange(len(history))
    
    # è®¾ç½®ç»˜å›¾é£æ ¼
    plt.style.use('dark_background')
    fig, ax = plt.subplots(figsize=(10, 6)) # å›¾ç‰‡å¤§å° 10x6 è‹±å¯¸
    
    # å®šä¹‰é¢œè‰²å’Œæ ‡ç­¾
    labels = ['Prox (Dist)', 'Sev (Fire)', 'Bat', 'Wat', 'Wind', 'Obs']
    indices = [0, 1, 2, 3, 5, 4]
    colors = ['#ff3333', '#ffaa00', '#00ff00', '#3399ff', '#00ffff', '#aa66ff']
    
    # ç»˜åˆ¶çº¿æ¡
    for i, idx in enumerate(indices):
        ax.plot(x_axis, data_np[:, i], label=labels[i], color=colors[i], linewidth=1.5)
    
    # è®¾ç½®è£…é¥°
    ax.set_title(f"EcoGuardian ML Weights Evolution (Gen {generation} - Frame {frame})")
    ax.set_xlabel("Simulation Frames")
    ax.set_ylabel("Weight Value")
    ax.set_ylim(-0.8, 1.2) # å›ºå®š Y è½´èŒƒå›´
    ax.grid(True, linestyle='--', alpha=0.3)
    ax.legend(loc='upper right')
    
    # ä¿å­˜æ–‡ä»¶
    filename = f"{save_dir}/gen_{generation}_frame_{frame}.png"
    plt.savefig(filename, dpi=100)
    plt.close(fig) # å…³é—­å›¾è¡¨é‡Šæ”¾å†…å­˜
    print(f"[System] ğŸ“¸ Chart saved to {filename}")

# è®¡ç®—æŒ‡å®šä½ç½®å‘¨å›´çš„éšœç¢ç‰©å¯†åº¦ (å½’ä¸€åŒ–è¾“å‡º 0~1)
def get_local_obs_density(grid_map, x, y):
    x1, x2 = max(0, x - 1), min(grid_map.width, x + 2)
    y1, y2 = max(0, y - 1), min(grid_map.height, y + 2)
    area = grid_map.grid[x1:x2, y1:y2]
    return np.sum(area == 3) / area.size


# ç»˜åˆ¶ä¾§è¾¹æ 
def draw_sidebar(surface, env, predictor, ga, logs, discovered_count):
    pygame.draw.rect(
        surface, (40, 40, 40), (GRID_WIDTH * CELL_SIZE, 0, SIDEBAR_WIDTH, WINDOW_HEIGHT)
    )
    font = pygame.font.SysFont("Arial", 14)
    info = [
        f"--- ECO GUARDIAN 2.0 ---",
        f"Gen: {ga.generation} | Frame: {ga.current_idx}",
        f"Extinguished: {np.sum(env.grid==6)}",
        f"Discovered Fires: {discovered_count}",
        f"Penalty: {PREDICTION_PENALTY:.1f}",
        f"------------------------",
        f"ML Weights (Normalized):",
        f"W_Prox: {predictor.weights[0]:.3f}",
        f"W_Sev:  {predictor.weights[1]:.3f}",
        f"W_Bat:  {predictor.weights[2]:.3f}",
        f"W_Wat:  {predictor.weights[3]:.3f}",
        f"W_Obs:  {predictor.weights[4]:.3f}",
        f"W_Wnd:  {predictor.weights[5]:.3f}", # æ˜¾ç¤ºé£å‘æƒé‡
        f"------------------------",
        f"LOGS:",
    ] + logs[-10:]
    for i, text in enumerate(info):
        surface.blit(
            font.render(text, True, (200, 200, 200)),
            (GRID_WIDTH * CELL_SIZE + 10, 20 + i * 22),
        )


def main():
    pygame.init()
    screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
    clock = pygame.time.Clock()

    # å…¨å±€å˜é‡å£°æ˜
    global PREDICTION_PENALTY

    env = GridMap()

    # åˆå§‹ç‚¹ç«
    for _ in range(3):
        env.ignite_random()

    discovered_fires = set()

    # åˆå§‹åŒ– AI æ¨¡å—
    predictor = EfficiencyPredictor(ML_LEARNING_RATE)
    ga = GeneticOptimizer(pop_size=4)
    current_penalty = ga.get_current_genome().penalty
    last_extinguished_total = 0 # ç”¨äºè®¡ç®—æœ¬å‘¨æœŸå†…çš„ç­ç«å¢é‡

    # åˆå§‹åŒ– Agents
    robots = [Robot(i, env.depots[i % 4][0], env.depots[i % 4][1]) for i in range(3)]
    supporter = SupportBot(99, env.depots[0][0], env.depots[0][1])
    drones = [Drone(201, 10, 10), Drone(202, 30, 20)]

    frame, logs = 0, []
    weight_history = [] # ç”¨äºå­˜å‚¨å†å²æƒé‡æ•°æ®
    
    while True:
        frame += 1
        current_genome = ga.get_current_genome()
        if not hasattr(current_genome, 'idle_frames'):
            current_genome.idle_frames = 0
        # --- äº‹ä»¶å¤„ç† ---
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
                env.ignite_random()

        # --- ç¯å¢ƒæ›´æ–° ---
        if frame % 12 == 0:
            env.update_fire_spread()

        # --- æ— äººæœºæ„ŸçŸ¥å¾ªç¯ ---
        for drone in drones:
            drone.step(env, frame)
            new_reports = drone.scan(env, frame)
            for f_pos in new_reports:
                discovered_fires.add((int(f_pos[0]), int(f_pos[1])))

        # æ¸…ç†å·²ç†„ç­çš„ç«ç‚¹
        discovered_fires = {
            f for f in discovered_fires if env.get_state(f[0], f[1]) == 2
        }

        # --- [æ ¸å¿ƒé€»è¾‘] ä»»åŠ¡è°ƒåº¦ (Dispatcher) ---
        if frame % 20 == 0:
            # 1. è·å–èµ„æº
            idle_robots = [r for r in robots if r.status == "IDLE"]
            active_fires = list(discovered_fires)

            if idle_robots and active_fires:
                # æŒ‰ç«åŠ¿é™åºæ’åˆ—
                def get_fire_severity(pos):
                    fx, fy = pos
                    # 1. è®¡ç®—å®‰å…¨çš„åˆ‡ç‰‡è¾¹ç•Œï¼Œé˜²æ­¢è´Ÿæ•°ç´¢å¼•å¯¼è‡´çš„â€œç©¿å¢™â€è¯»å–
                    x_min = max(0, fx - 1)
                    x_max = min(env.width, fx + 2)
                    y_min = max(0, fy - 1)
                    y_max = min(env.height, fy + 2)
                    
                    # 2. å®‰å…¨åˆ‡ç‰‡
                    area = env.grid[x_min:x_max, y_min:y_max]
                    
                    # 3. è®¡ç®—ä¸¥é‡åº¦ (ä¾ç„¶é™¤ä»¥ 9.0 åšå½’ä¸€åŒ–ï¼Œä¿æŒç‰¹å¾å°ºåº¦ä¸€è‡´)
                    return np.sum(area == 2) / 9.0

                active_fires.sort(key=get_fire_severity, reverse=True)

                for f_pos in active_fires:
                    if not idle_robots:
                        break

                    # [å…³é”®é€»è¾‘] æ‰©å¤§çš„ç¤¾äº¤è·ç¦»æ£€æŸ¥ (Radius = 4)
                    is_crowded = False
                    for r in robots:
                        target = r.target if r.target else (r.x, r.y)
                        if abs(target[0] - f_pos[0]) + abs(target[1] - f_pos[1]) <= current_genome.radius:
                            is_crowded = True; break

                    if is_crowded:
                        continue  # å¤ªæŒ¤äº†ï¼Œæ¢ä¸‹ä¸€ä¸ªç«ç‚¹

                    severity = get_fire_severity(f_pos)

                    # ç«ä»·é€‰æ‹”
                    best_robot = None
                    min_cost = 999999
                    best_feat = None

                    for r in idle_robots:
                        dist_m = abs(r.x - f_pos[0]) + abs(r.y - f_pos[1])
                        # æ–¹æ¡ˆ Bï¼šé£å‘å¯¹é½åº¦ç‰¹å¾
                        vec_x = (f_pos[0] - r.x) / (dist_m if dist_m > 0 else 1)
                        vec_y = (f_pos[1] - r.y) / (dist_m if dist_m > 0 else 1)
                        wind_align = vec_x * env.wind_direction[0] + vec_y * env.wind_direction[1]
                        max_map_dist = GRID_WIDTH + GRID_HEIGHT

                        feats = [
                            1.0 - (dist_m / max_map_dist),                 # ä½¿ç”¨åŠ¨æ€åœ°å›¾å°ºå¯¸
                            get_fire_severity(f_pos),                      # å‡½æ•°å†…éƒ¨å·²å½’ä¸€åŒ– (/9.0)
                            r.battery / ROBOT_MAX_BATTERY,                 # ä½¿ç”¨å¸¸é‡ (200)
                            r.water / ROBOT_MAX_WATER,                     # ä½¿ç”¨å¸¸é‡ (30)
                            get_local_obs_density(env, f_pos[0], f_pos[1]),# å‡½æ•°å†…éƒ¨å·²å½’ä¸€åŒ–
                            wind_align                                     # è‡ªç„¶å½’ä¸€åŒ– (-1~1)
                        ]

                        cost = r.calculate_bid(
                            f_pos,
                            feats,
                            predictor,
                            current_genome.penalty,
                        )

                        if cost < min_cost:
                            min_cost = cost
                            best_robot = r
                            best_feat = feats

                    # æ´¾é£é€»è¾‘
                    if best_robot and min_cost < BID_REJECT_THRESHOLD:
                        if best_robot.set_target(f_pos[0], f_pos[1], env, best_feat):
                            idle_robots.remove(best_robot)
                            msg = f"Dispatch: Fire {f_pos} -> Bot {best_robot.id}"
                            logs.append(msg)
                            print(msg) # [æ¢å¤æ§åˆ¶å°æ—¥å¿—]
        #grid_before = env.grid.copy()
        # --- æ‰§è¡Œ Agent æ›´æ–° ---
        for r in robots:
            # [å…³é”®] å¿…é¡»ä¼ å…¥ robots åˆ—è¡¨ä¾›å†…éƒ¨é¿å«Œä½¿ç”¨
            r.step(env, predictor, robots, current_genome=current_genome)
        supporter.step(env, robots)
        idle_count = sum(1 for r in robots if r.status == "IDLE")
        current_genome.idle_frames += idle_count
        indices_to_plot = [0, 1, 2, 3, 5, 4] # Prox, Sev, Bat, Wat, Wind, Obs
        current_weights = [predictor.weights[i] for i in indices_to_plot]
        weight_history.append(current_weights)
        # --- é—ä¼ ç®—æ³•è¿›åŒ– ---
        if frame % GA_EVOLVE_INTERVAL == 0:
            current_total = np.sum(env.grid == 6)
            current_genome = ga.get_current_genome()
            current_genome.extinguished_count = current_total - last_extinguished_total
            last_extinguished_total = current_total
            current_genome.stranded_count = sum(1 for r in robots if r.status == "STRANDED")
            log_system_status(frame, env, robots, predictor, ga, current_penalty)
            print(f"[GA Eval] Gen {ga.generation}: Ext:{current_genome.extinguished_count}, "
                  f"SevBonus:{current_genome.severity_bonus:.1f}, Stranded:{current_genome.stranded_count}")
            save_weight_chart(weight_history, frame, ga.generation)
            ga.next_step()
            current_penalty = ga.get_current_genome().penalty 

        # --- æ¸²æŸ“ç”»é¢ ---
        screen.fill(COLOR_BG)
        for x in range(env.width):
            for y in range(env.height):
                color = {
                    0: COLOR_EMPTY,
                    1: COLOR_TREE,
                    2: COLOR_FIRE,
                    3: COLOR_WALL,
                    4: COLOR_BURNT,
                    5: COLOR_DEPOT,
                    6: COLOR_EXTINGUISHED,
                }.get(env.grid[x, y])
                pygame.draw.rect(
                    screen, color, (x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE)
                )

        for r in robots:
            r.draw(screen)
        for d in drones:
            d.draw(screen)
        supporter.draw(screen)
        draw_sidebar(screen, env, predictor, ga, logs, len(discovered_fires))
        pygame.display.flip()
        clock.tick(FPS)


if __name__ == "__main__":
    # åŠ«æŒæ‰€æœ‰è¾“å‡ºåˆ°æ—¥å¿—æ–‡ä»¶
    logger = Logger("simulation.log")
    sys.stdout = logger
    sys.stderr = logger
    print("--- Simulation Started: Logging to simulation.log ---")
    main()



================================================
FILE: question.md
================================================
ä»¥ä¸‹æ˜¯æˆ‘ä»¬åœ¨ EcoGuardian 2.0 ç³»ç»Ÿä¸­å‘ç°å¹¶ä¿®å¤çš„æ‰€æœ‰å…³é”®é—®é¢˜æ¸…å•ï¼š

### 1. åŸºç¡€é€»è¾‘ä¸æ¶æ„å±‚

*   **é—®é¢˜ï¼šå†·å¯åŠ¨æ­»é” (Cold Start Deadlock)**
    *   **ç°è±¡**ï¼šç¨‹åºåˆšå¯åŠ¨æ—¶ï¼Œæœºå™¨äººçœ‹åˆ°ç«ä¹Ÿä¸åŠ¨ã€‚
    *   **åŸå› **ï¼šåˆå§‹ `PREDICTION_PENALTY` (2000) è¿‡é«˜ï¼Œå¯¼è‡´è®¡ç®—å‡ºçš„ç«ä»·æˆæœ¬ (Cost) è¶…è¿‡äº†æ‹’ç»é˜ˆå€¼ (Threshold)ï¼Œæ‰€æœ‰ä»»åŠ¡éƒ½è¢«ç³»ç»Ÿâ€œæ‹’å•â€ã€‚
    *   **ä¿®å¤**ï¼šåœ¨ `main()` åˆå§‹åŒ–é˜¶æ®µå¼ºåˆ¶å°† `PREDICTION_PENALTY` è®¾ä¸º **500.0**ï¼Œå¹¶åœ¨ `settings.py` ä¸­æé«˜æ‹’ç»é˜ˆå€¼è‡³ **5000.0**ï¼Œæ‰©å¤§æ•°å€¼è¿ä½œç©ºé—´ã€‚

*   **é—®é¢˜ï¼šå˜é‡ä½œç”¨åŸŸå¤±æ•ˆ (Scope Issue)**
    *   **ç°è±¡**ï¼šä¿®æ”¹äº† `main.py` çš„å‚æ•°ï¼Œä½†æœºå™¨äººè¡Œä¸ºæ²¡å˜åŒ–ã€‚
    *   **åŸå› **ï¼šPython çš„ `from settings import *` æœºåˆ¶å¯¼è‡´ `robot.py` æŒæœ‰çš„æ˜¯æ—§å¸¸é‡çš„å‰¯æœ¬ï¼Œæ„ŸçŸ¥ä¸åˆ° `main.py` ä¸­å…¨å±€å˜é‡çš„å˜åŒ–ã€‚
    *   **ä¿®å¤**ï¼šä¿®æ”¹ `robot.calculate_bid()` æ–¹æ³•ï¼Œ**å¢åŠ  `penalty` å‚æ•°**ï¼Œå®ç°ä» `main.py` åˆ° `Robot` å®ä¾‹çš„åŠ¨æ€é€ä¼ ã€‚

*   **é—®é¢˜ï¼šè¯­æ³•é”™è¯¯ (Syntax Error)**
    *   **ç°è±¡**ï¼š`SyntaxError: name assigned to before global declaration`ã€‚
    *   **åŸå› **ï¼š`global` å£°æ˜è¯­å¥çš„ä½ç½®æ™šäºå˜é‡çš„ä½¿ç”¨ä½ç½®ã€‚
    *   **ä¿®å¤**ï¼šå°† `global PREDICTION_PENALTY` ç§»è‡³ `main()` å‡½æ•°çš„**ç¬¬ä¸€è¡Œ**ã€‚

### 2. å¤šæ™ºèƒ½ä½“åä½œå±‚ (Multi-Agent)

*   **é—®é¢˜ï¼šä¸¥é‡çš„ç¾Šç¾¤æ•ˆåº” (Herding Effect)**
    *   **ç°è±¡**ï¼šå¤šä¸ªæœºå™¨äººæŒ¤åœ¨ä¸€èµ·å»æŠ¢åŒä¸€ä¸ªç«ç‚¹ï¼Œå¯¼è‡´ç”±äºè·¯å¾„å†²çªæˆ–é‡å¤åŠ³åŠ¨è€Œæµªè´¹èµ„æºã€‚
    *   **åŸå› **ï¼š
        1.  æ—§çš„ä»»åŠ¡è°ƒåº¦ç®—æ³•ä¼šæ ¹æ®ç«åŠ¿å¼ºåˆ¶åˆ†é…å¤šä¸ªæœºå™¨äºº (`needed_bots > 1`)ã€‚
        2.  ç¼ºä¹â€œäº’æ–¥æ£€æµ‹â€ï¼Œæœºå™¨äººä¸çŸ¥é“é˜Ÿå‹å·²ç»å»äº†ç›®æ ‡é™„è¿‘çš„æ ¼å­ã€‚
    *   **ä¿®å¤**ï¼š
        1.  **å¼ºåˆ¶å•äººå•ç«**ï¼šæ— è®ºç«åŠ¿å¤šå¤§ï¼Œä¸€è½®è°ƒåº¦åªæ´¾ä¸€ä¸ªæœºå™¨äººã€‚
        2.  **ç¤¾äº¤è·ç¦» (Social Distancing)**ï¼šå»ºç«‹ `occupied_targets` ç¼“å­˜ï¼Œå¦‚æœæŸç«ç‚¹å‘¨å›´ **2æ ¼å†…** å·²æœ‰æœºå™¨äººå‰å¾€ï¼Œåç»­æœºå™¨äººç›´æ¥è·³è¿‡è¯¥ç«ç‚¹ï¼ˆç¡¬çº¦æŸï¼‰ã€‚

### 3. æœºå™¨å­¦ä¹ ä¸ä¼˜åŒ–å±‚ (ML & GA)

*   **é—®é¢˜ï¼šæ¢¯åº¦çˆ†ç‚¸ä¸è®­ç»ƒéœ‡è¡ (Gradient Explosion)**
    *   **ç°è±¡**ï¼šML æƒé‡å¿½å¤§å¿½å°ï¼Œéš¾ä»¥æ”¶æ•›ã€‚
    *   **åŸå› **ï¼šç‰¹å¾æ•°å€¼å·®å¼‚è¿‡å¤§ï¼ˆä¾‹å¦‚ï¼šè·ç¦»ç‰¹å¾æ˜¯ 0~60ï¼Œè€Œç”µæ± ç‰¹å¾æ˜¯ 0~1ï¼‰ã€‚å¤§æ•°å€¼ç‰¹å¾ä¸»å¯¼äº†æ¢¯åº¦ä¸‹é™ï¼Œå¯¼è‡´æ¨¡å‹â€œæ­¥å­è¿ˆå¤ªå¤§â€ã€‚
    *   **ä¿®å¤**ï¼šåœ¨ `main.py` ä¸­å®æ–½**ç‰¹å¾å½’ä¸€åŒ– (Feature Normalization)**ï¼Œå°†è·ç¦»ã€ç«åŠ¿ã€éšœç¢ç‰©å¯†åº¦å…¨éƒ¨æ˜ å°„åˆ° **0.0 ~ 1.0** åŒºé—´ã€‚

*   **é—®é¢˜ï¼šç™½æ¿èµ·æ­¥ (Tabula Rasa) å¯¼è‡´çš„é”™è¯¯è®¤çŸ¥**
    *   **ç°è±¡**ï¼šML è®­ç»ƒå‡ºè¿åå¸¸è¯†çš„æƒé‡ï¼ˆä¾‹å¦‚ï¼šè·ç¦»æƒé‡ä¸ºè´Ÿï¼Œè®¤ä¸ºâ€œç¦»å¾—è¶Šè¿‘è¶Šå®¹æ˜“å¤±è´¥â€ï¼‰ã€‚
    *   **åŸå› **ï¼šæ¨¡å‹åˆå§‹æƒé‡å…¨ä¸º 0ï¼Œæ—©æœŸçš„éšæœºæˆè´¥è®©æ¨¡å‹å­¦åˆ°äº†é”™è¯¯çš„å› æœå…³ç³»ï¼ˆâ€œç¬¬ä¸€å°è±¡åå·®â€ï¼‰ã€‚
    *   **ä¿®å¤**ï¼š**å¯å‘å¼åˆå§‹åŒ– (Heuristic Initialization)**ã€‚åœ¨ `Predictor` åˆå§‹åŒ–æ—¶äººå·¥æ¤å…¥â€œå¸¸è¯†â€ï¼ˆå¦‚ï¼šè·ç¦»æƒé‡è®¾ä¸º +0.5ï¼Œéšœç¢æƒé‡è®¾ä¸º -0.5ï¼‰ï¼Œè®©æ¨¡å‹åœ¨æ­£ç¡®çš„åŸºç¡€ä¸Šå¾®è°ƒï¼Œè€Œä¸æ˜¯ä»é›¶ççŒœã€‚

*   **é—®é¢˜ï¼šå­¦ä¹ æœºåˆ¶è¿‡äºç®€å•**
    *   **ä¿®å¤**ï¼š
        1.  å¼•å…¥ **å­¦ä¹ ç‡è¡°å‡ (LR Decay)**ï¼Œéšç€è®­ç»ƒæ¬¡æ•°å¢åŠ é™ä½æ­¥é•¿ï¼Œä¿è¯åæœŸç¨³å®šã€‚
        2.  å¼•å…¥ **æƒé‡å‰ªè£ (Weight Clipping)**ï¼Œé˜²æ­¢æƒé‡æ•°å€¼æ— é™è†¨èƒ€ã€‚
        3.  åŠ å¼º **è´Ÿåé¦ˆåŠ›åº¦**ï¼Œè®©é—ä¼ ç®—æ³•ï¼ˆGAï¼‰å¯¹æ‰å †è¡Œä¸ºçš„æƒ©ç½šä» 1.0 æå‡è‡³ 15.0ã€‚



================================================
FILE: requirements.txt
================================================
numpy
pygame


================================================
FILE: æŠ€æœ¯æ–‡æ¡£.md
================================================
è¿™æ˜¯ä¸€ä¸ªåŸºäºæ‚¨æä¾›çš„ Python ä»£ç ç”Ÿæˆçš„ UML ç±»å›¾ã€‚

### ç±»å›¾æ¦‚è§ˆ

è¯¥å›¾ä¸»è¦å±•ç¤ºäº†ä»¥ä¸‹å‡ ä¸ªæ ¸å¿ƒéƒ¨åˆ†ï¼š

1. **ä»£ç†ç»§æ‰¿ä½“ç³» (Agent Hierarchy)**: `BaseAgent` ä½œä¸ºåŸºç±»ï¼Œ`Drone` (æ— äººæœº), `Robot` (æ¶ˆé˜²æœºå™¨äºº), `SupportBot` (åå‹¤æœºå™¨äºº) ç»§æ‰¿è‡ªå®ƒã€‚
2. **æ ¸å¿ƒç¯å¢ƒä¸é€»è¾‘ (Core Logic)**: `GridMap` (åœ°å›¾ç¯å¢ƒ), `EfficiencyPredictor` (æœºå™¨å­¦ä¹ é¢„æµ‹å™¨), `GeneticOptimizer` (é—ä¼ ç®—æ³•ä¼˜åŒ–å™¨) åŠå…¶ç»„æˆçš„ `Genome` (åŸºå› ç»„)ã€‚
3. **è¾…åŠ©ç±» (Helpers)**: `Logger` (æ—¥å¿—è®°å½•) å’Œ `Node` (å¯»è·¯èŠ‚ç‚¹)ã€‚

### UML ç±»å›¾ (ä½¿ç”¨ Mermaid è¯­æ³•æ¸²æŸ“)

```mermaid
classDiagram
    %% ================== ä»£ç†ç»§æ‰¿ä½“ç³» ==================
    class BaseAgent {
        +id: any
        +x: int
        +y: int
        +color: tuple
        +type: str
        +__init__(agent_id, x, y, color)
        +move(dx, dy, grid_width, grid_height) bool
        +draw(surface)
    }

    class Drone {
        +type: str = "UAV"
        +scan_radius: int
        +target: tuple or None
        +__init__(agent_id, x, y)
        +select_new_target(grid_map, frame_id)
        +step(grid_map, frame_id)
        +scan(grid_map, frame_id) list
        +draw(surface)
    }

    class Robot {
        +status: str
        +target: tuple or None
        +current_path: list
        +battery: int
        +water: int
        +last_task_features: list or None
        +idle_timer: int
        +__init__(agent_id, x, y)
        +aoe_extinguish(grid_map, current_genome) bool
        +find_local_fire(grid_map, neighbors, search_radius, dynamic_radius) tuple or None
        +step(grid_map, predictor, neighbors, current_genome)
        +set_target(tx, ty, grid_map, feats) bool
        +calculate_bid(fire_pos, feats, predictor, penalty) float
        +draw(surface)
    }

    class SupportBot {
        +target_robot: Robot or None
        +path: list
        +__init__(agent_id, x, y)
        +step(grid_map, all_robots)
    }

    Drone --|> BaseAgent : Inherits
    Robot --|> BaseAgent : Inherits
    SupportBot --|> BaseAgent : Inherits

    %% ================== æ ¸å¿ƒç¯å¢ƒä¸é€»è¾‘ ==================
    class GridMap {
        +width: int
        +height: int
        +grid: np.array
        +fuel_grid: np.array
        +last_scan_frame: np.array
        +dryness_grid: np.array
        +wind_name: str
        +wind_direction: tuple
        +depots: list
        +WIND_DATA: list
        +__init__(width, height)
        +generate_forest(density)
        +update_dryness()
        +update_fire_spread()
        +ignite_random() tuple or None
        +get_state(x, y) int
        +set_state(x, y, state)
        +mark_scanned(cx, cy, radius, frame_id)
        +get_average_urgency(cx, cy, radius, frame_id) float
    }

    class EfficiencyPredictor {
        +lr: float
        +base_lr: float
        +weights: np.array
        +training_count: int
        +__init__(learning_rate)
        +sigmoid(x) float
        +predict_prob(features) float
        +train(features, label)
    }

    class GeneticOptimizer {
        +pop_size: int
        +population: list[Genome]
        +current_idx: int
        +generation: int
        +__init__(pop_size)
        +evaluate_fitness(genome) float
        +get_current_genome() Genome
        +record_success()
        +record_crowding()
        +next_step() bool
        +evolve()
    }

    class Genome {
        +penalty: float
        +radius: int
        +fitness: float
        +extinguished_count: int
        +severity_bonus: float
        +stranded_count: int
        +crowded_frames: int
        +idle_frames: int
        +__init__(penalty, radius)
        +mutate(rate)
    }

    GeneticOptimizer o-- Genome : Contains List of

    %% ================== è¾…åŠ©ç±»ä¸æ¨¡å— ==================
    class Node {
        +parent: Node or None
        +position: tuple
        +g: float
        +h: float
        +f: float
        +__init__(parent, position)
        +__eq__(other)
        +__lt__(other)
    }

    class PathfindingModule {
        <<module>>
        +astar(grid_map, start, end, has_water) list or None
    }

    class Logger {
        +terminal_out: stream
        +terminal_err: stream
        +log: file_handle
        +__init__(filename)
        +write(message)
        +flush()
    }

    %% ================== å…³ç³»ä¸ä¾èµ– ==================
    %% ä»£ç†ä¾èµ–ç¯å¢ƒ
    Drone ..> GridMap : Uses to scan/move
    Robot ..> GridMap : Uses to move/extinguish
    SupportBot ..> GridMap : Uses to move

    %% ä»£ç†ä¾èµ–å…¶ä»–é€»è¾‘
    Robot --> EfficiencyPredictor : Uses for bidding/training
    Robot ..> Genome : Uses parameters
    SupportBot --> Robot : Targets to rescue

    %% å¯»è·¯ä¾èµ–
    PathfindingModule ..> Node : Uses internally
    Robot ..> PathfindingModule : Calls astar
    SupportBot ..> PathfindingModule : Calls astar

    %% ä¸»ç¨‹åºé€»è¾‘ï¼ˆéšå¼å…³ç³»ï¼Œé€šè¿‡å‚æ•°ä¼ é€’ä½“ç°ï¼‰
    Robot ..> Robot : Neighbors list in step()
    SupportBot ..> Robot : all_robots list in step()

```

### å…³é”®è¯´æ˜

1. **ç¬¦å·è¯´æ˜**:
* `+`: è¡¨ç¤º Public å±æ€§æˆ–æ–¹æ³• (Python ä¸­é»˜è®¤éƒ½æ˜¯ Public)ã€‚
* `--|>`: ç»§æ‰¿å…³ç³» (Inheritance)ã€‚
* `o--`: èšåˆå…³ç³» (Aggregation)ï¼Œä¾‹å¦‚ GeneticOptimizer åŒ…å«å¤šä¸ª Genomeã€‚
* `-->`: å…³è”å…³ç³» (Association)ï¼Œè¡¨ç¤ºä¸€ä¸ªç±»æŒæœ‰å¦ä¸€ä¸ªç±»çš„å¼•ç”¨ï¼Œæˆ–è€…ä¸å…¶æœ‰å¼ºäº¤äº’ã€‚
* `..>`: ä¾èµ–å…³ç³» (Dependency)ï¼Œè¡¨ç¤ºä¸€ä¸ªç±»åœ¨æŸä¸ªæ–¹æ³•ä¸­ä½¿ç”¨åˆ°äº†å¦ä¸€ä¸ªç±»ä½œä¸ºå‚æ•°æˆ–å±€éƒ¨å˜é‡ã€‚


2. **PathfindingModule**:
åœ¨æ‚¨çš„ä»£ç ä¸­ï¼Œ`astar` æ˜¯ `core/pathfinding.py` ä¸­çš„ä¸€ä¸ªç‹¬ç«‹å‡½æ•°ï¼Œè€Œä¸æ˜¯ç±»çš„æ–¹æ³•ã€‚ä¸ºäº†åœ¨ç±»å›¾ä¸­å‡†ç¡®è¡¨ç¤ºè¿™ä¸€ç‚¹ï¼Œæˆ‘åˆ›å»ºäº†ä¸€ä¸ªæ„é€ å‹ä¸º `<<module>>` çš„ `PathfindingModule` æ¡†æ¥å®¹çº³è¿™ä¸ªå‡½æ•°ï¼Œå¹¶æ˜¾ç¤ºäº†ä»£ç†ç±»å¯¹å®ƒçš„ä¾èµ–ã€‚
3. **ç±»å‹æ¨æ–­**:
å±æ€§å’Œå‚æ•°çš„ç±»å‹æ˜¯æ ¹æ®ä»£ç ä¸Šä¸‹æ–‡æ¨æ–­çš„ï¼ˆä¾‹å¦‚ï¼Œåæ ‡æ¨æ–­ä¸º `int`ï¼Œæƒé‡æ¨æ–­ä¸º `np.array`ï¼Œé¢œè‰²æ¨æ–­ä¸º `tuple`ï¼‰ã€‚
4. **Main.py**:
`main.py` æ˜¯è„šæœ¬å…¥å£ç‚¹ï¼Œå®ƒè´Ÿè´£å®ä¾‹åŒ–ä¸Šè¿°æ‰€æœ‰çš„ç±»å¹¶è¿è¡Œä¸»å¾ªç¯ã€‚å®ƒæœ¬èº«ä¸æ˜¯ä¸€ä¸ªç±»ï¼Œå› æ­¤æ²¡æœ‰åœ¨ç±»å›¾ä¸­è¡¨ç¤ºä¸ºä¸€ä¸ªå•ç‹¬çš„æ¡†ï¼Œä½†å›¾ä¸­çš„å„ç§ä¾èµ–å…³ç³»æ­£æ˜¯é€šè¿‡ `main.py` ä¸­çš„é€»è¾‘è¿æ¥èµ·æ¥çš„ï¼ˆä¾‹å¦‚ï¼Œå°† `GridMap` å®ä¾‹ä¼ é€’ç»™ `Robot.step()` æ–¹æ³•ï¼‰ã€‚

è¿™æ˜¯åŸºäºä½ æä¾›çš„ Python ä»£ç ç”Ÿæˆçš„ UML ç±»å›¾ã€‚

æˆ‘å°†ä½¿ç”¨æ ‡å‡†çš„ UML ç¬¦å·æ¥è¡¨ç¤ºï¼š

* `+` è¡¨ç¤ºå…±æœ‰å±æ€§æˆ–æ–¹æ³• (Public)ã€‚
* å±æ€§æ ¼å¼ï¼š`+å±æ€§å : ç±»å‹`
* æ–¹æ³•æ ¼å¼ï¼š`+æ–¹æ³•å(å‚æ•°å : å‚æ•°ç±»å‹) : è¿”å›ç±»å‹`

### UML ç±»å›¾å¯è§†åŒ–

```mermaid
classDiagram
    class BaseAgent {
        %% å±æ€§ (Attributes)
        +id : any
        +x : int
        +y : int
        +color : any
        +type : str

        %% æ–¹æ³• (Methods)
        +BaseAgent(agent_id: any, x: int, y: int, color: any)
        +move(dx: int, dy: int, grid_width: int, grid_height: int) bool
        +draw(surface: pygame.Surface) void
    }

```

---

### è¯¦ç»†è¯´æ˜

1. **ç±»å (Class Name):**
* `BaseAgent`ï¼šä½äºå›¾è¡¨çš„é¡¶éƒ¨ã€‚


2. **å±æ€§ (Attributes):**
* è¿™äº›æ˜¯ä» `__init__` æ–¹æ³•ä¸­æå–çš„ `self.*` å˜é‡ã€‚
* `+id`ï¼šæ™ºèƒ½ä½“çš„å”¯ä¸€æ ‡è¯†ç¬¦ã€‚Python ä¸­ç±»å‹ä¸å›ºå®šï¼Œè¿™é‡Œæ ‡æ³¨ä¸º `any` (æˆ–è€…é€šå¸¸æ˜¯ `int` æˆ– `str`)ã€‚
* `+x`, `+y`ï¼šæ™ºèƒ½ä½“çš„åæ ‡ã€‚æ ¹æ® `move` æ–¹æ³•ä¸­çš„è®¡ç®—ï¼Œç±»å‹æ¨æ–­ä¸ºæ•´æ•° `int`ã€‚
* `+color`ï¼šç”¨äº Pygame ç»˜åˆ¶çš„é¢œè‰²ã€‚é€šå¸¸æ˜¯ä¸€ä¸ª RGB å…ƒç»„æˆ– Pygame Color å¯¹è±¡ï¼Œè¿™é‡Œæ ‡æ³¨ä¸º `any`ã€‚
* `+type`ï¼šåˆå§‹åŒ–æ—¶è¢«èµ‹å€¼ä¸ºå­—ç¬¦ä¸² `"Base"`ï¼Œç±»å‹ä¸º `str`ã€‚


3. **æ–¹æ³• (Methods):**
* `+BaseAgent(...)`ï¼šè¿™æ˜¯æ„é€ å‡½æ•° (`__init__`)ã€‚
* `+move(...)`ï¼š
* æ¥æ”¶ `dx`, `dy`, `grid_width`, `grid_height` ä½œä¸ºæ•´æ•°å‚æ•°ã€‚
* è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ (`bool`)ï¼Œè¡¨ç¤ºç§»åŠ¨æ˜¯å¦æˆåŠŸã€‚


* `+draw(...)`ï¼š
* æ¥æ”¶ä¸€ä¸ª `surface` å‚æ•°ï¼Œè¿™æ˜¯ Pygame ç”¨äºç»˜å›¾çš„å¯¹è±¡ (æ ‡æ³¨ä¸º `pygame.Surface`)ã€‚
* æ²¡æœ‰è¿”å›å€¼ (æ ‡æ³¨ä¸º `void`)ã€‚





*æ³¨æ„ï¼šä»£ç ä¸­ä½¿ç”¨çš„ `CELL_SIZE` æ˜¯ä»å¤–éƒ¨å¯¼å…¥çš„å…¨å±€å¸¸é‡ï¼Œä¸å±äºç±»çš„æˆå‘˜å±æ€§ï¼Œå› æ­¤ä¸ä¼šå‡ºç°åœ¨ç±»å›¾ä¸­ã€‚*


================================================
FILE: agents/base_agent.py
================================================
# agents\base_agent.py
import pygame
from configs.settings import *

class BaseAgent:
    def __init__(self, agent_id, x, y, color):
        """åˆå§‹åŒ–åŸºç±»ä»£ç†"""
        self.id = agent_id # æ™ºèƒ½ä½“id
        self.x = x # æ™ºèƒ½ä½“åæ ‡ x
        self.y = y # æ™ºèƒ½ä½“åæ ‡ y
        self.color = color # æ™ºèƒ½ä½“é¢œè‰²
        self.type = "Base" # æ™ºèƒ½ä½“ç±»å‹

    def move(self, dx, dy, grid_width, grid_height):
        """å°è¯•ç§»åŠ¨ï¼Œå¦‚æœå‡ºç•Œåˆ™ä¸ç§»åŠ¨"""
        nx, ny = self.x + dx, self.y + dy # æ–°çš„xåæ ‡å’Œyåæ ‡
        if 0 <= nx < grid_width and 0 <= ny < grid_height: # å¦‚æœæ–°çš„xåæ ‡å’Œyåæ ‡åœ¨åœ°å›¾èŒƒå›´å†…
            self.x = nx # æ›´æ–°xåæ ‡
            self.y = ny # æ›´æ–°yåæ ‡
            return True # è¿”å›Trueè¡¨ç¤ºç§»åŠ¨æˆåŠŸ
        return False # è¿”å›Falseè¡¨ç¤ºç§»åŠ¨å¤±è´¥

    def draw(self, surface):
        """åœ¨å±å¹•ä¸Šç»˜åˆ¶è‡ªå·± (ç®€å•çš„æ–¹å—æˆ–åœ†å½¢)"""
        px = self.x * CELL_SIZE
        py = self.y * CELL_SIZE
        padding = 2
        rect = pygame.Rect(px + padding, py + padding, CELL_SIZE - padding*2, CELL_SIZE - padding*2)
        pygame.draw.rect(surface, self.color, rect)


================================================
FILE: agents/drone.py
================================================
import pygame
import random
from agents.base_agent import BaseAgent
from configs.settings import COLOR_UAV, CELL_SIZE


class Drone(BaseAgent):
    def __init__(self, agent_id, x, y):
        """åˆå§‹åŒ–æ— äººæœº"""
        super().__init__(agent_id, x, y, COLOR_UAV)
        self.type = "UAV"
        self.scan_radius = 4 # æ‰«æåŠå¾„
        self.target = None  # å·¡é€»ç›®æ ‡

    def select_new_target(self, grid_map, frame_id):
        """è’™ç‰¹å¡æ´›æ¢ç´¢ï¼šé£å‘æœ€ä¹…æ²¡çœ‹ï¼ˆç´§è¿«åº¦æœ€é«˜ï¼‰çš„åŒºåŸŸ"""
        best_score = -1 # æœ€é«˜ç´§è¿«åº¦
        best_target = None # æœ€é«˜ç´§è¿«åº¦ç›®æ ‡

        # éšæœºé‡‡æ · 20 ä¸ªç‚¹è¯„ä¼°è¦†ç›–ç‡
        for _ in range(20):
            rx = random.randint(0, grid_map.width - 1)
            ry = random.randint(0, grid_map.height - 1)
            score = grid_map.get_average_urgency(rx, ry, self.scan_radius, frame_id) # è®¡ç®—å¹³å‡ç´§è¿«åº¦
            if score > best_score:
                best_score = score # æ›´æ–°æœ€é«˜ç´§è¿«åº¦
                best_target = (rx, ry) # æ›´æ–°æœ€é«˜ç´§è¿«åº¦ç›®æ ‡

        self.target = best_target # æ›´æ–°å·¡é€»ç›®æ ‡

    def step(self, grid_map, frame_id):
        """æ— äººæœºé£è¡Œé€»è¾‘ï¼ˆæ— è§†åœ°å½¢ï¼‰"""
        # å¦‚æœæ²¡æœ‰å·¡é€»ç›®æ ‡ï¼Œé€‰æ‹©æ–°çš„ç›®æ ‡
        if not self.target:
            self.select_new_target(grid_map, frame_id) # å¦‚æœæ²¡æœ‰å·¡é€»ç›®æ ‡ï¼Œä½¿ç”¨è’™ç‰¹å¡æ´›æ¢ç´¢é€‰æ‹©æ–°çš„ç›®æ ‡

        tx, ty = self.target # ç›®æ ‡xåæ ‡å’Œyåæ ‡
        dx, dy = tx - self.x, ty - self.y # ç›®æ ‡xåæ ‡å’Œyåæ ‡ä¸å½“å‰xåæ ‡å’Œyåæ ‡ä¹‹å·®

        # ç¬¦å·å‡½æ•°ç§»åŠ¨ï¼šå¦‚æœç›®æ ‡xåæ ‡å¤§äºå½“å‰xåæ ‡ï¼Œåˆ™å‘å³ç§»åŠ¨ï¼Œå¦åˆ™å‘å·¦ç§»åŠ¨ï¼›å¦‚æœç›®æ ‡yåæ ‡å¤§äºå½“å‰yåæ ‡ï¼Œåˆ™å‘ä¸‹ç§»åŠ¨ï¼Œå¦åˆ™å‘ä¸Šç§»åŠ¨
        if dx > 0:
            step_x = 1
        elif dx < 0:
            step_x = -1
        else:
            step_x = 0
        if dy > 0:
            step_y = 1
        elif dy < 0:
            step_y = -1
        else:
            step_y = 0

        self.move(step_x, step_y, grid_map.width, grid_map.height) # ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®

        # åˆ°è¾¾é™„è¿‘åˆ™é‡é€‰ç›®æ ‡
        if abs(self.x - tx) + abs(self.y - ty) <= 1:
            self.select_new_target(grid_map, frame_id)

    def scan(self, grid_map, frame_id):
        """æ‰§è¡Œæ„ŸçŸ¥ä»»åŠ¡ï¼Œè¿”å›å‘ç°çš„ç«ç‚¹"""
        grid_map.mark_scanned(self.x, self.y, self.scan_radius, frame_id)
        found_fires = []
        # éå†æ— äººæœºæ‰«æåŠå¾„å†…çš„åŒºåŸŸï¼Œå¦‚æœåŒºåŸŸå†…æœ‰ç«ç‚¹ï¼Œåˆ™è®°å½•ç«ç‚¹åæ ‡
        for dx in range(-self.scan_radius, self.scan_radius + 1):
            for dy in range(-self.scan_radius, self.scan_radius + 1):
                nx, ny = self.x + dx, self.y + dy
                if grid_map.get_state(nx, ny) == 2:
                    found_fires.append((nx, ny))
        return found_fires

    def draw(self, surface):
        """ç»˜åˆ¶æ— äººæœº"""
        px, py = self.x * CELL_SIZE, self.y * CELL_SIZE # è®¡ç®—æ— äººæœºä¸­å¿ƒåæ ‡
        pygame.draw.circle(
            surface,
            self.color,
            (px + CELL_SIZE // 2, py + CELL_SIZE // 2),
            CELL_SIZE // 2 - 2,
        )
        # ç»˜åˆ¶æ‰«æèŒƒå›´é˜´å½±
        scan_rect = pygame.Rect(
            (self.x - self.scan_radius) * CELL_SIZE,
            (self.y - self.scan_radius) * CELL_SIZE,
            (self.scan_radius * 2 + 1) * CELL_SIZE,
            (self.scan_radius * 2 + 1) * CELL_SIZE,
        )
        s = pygame.Surface((scan_rect.width, scan_rect.height), pygame.SRCALPHA)
        pygame.draw.rect(
            s, (0, 191, 255, 30), (0, 0, scan_rect.width, scan_rect.height)
        )
        surface.blit(s, (scan_rect.x, scan_rect.y))



================================================
FILE: agents/robot.py
================================================
[Binary file]


================================================
FILE: configs/settings.py
================================================
# --- å±å¹•ä¸ç½‘æ ¼é…ç½® ---
GRID_WIDTH = 40
GRID_HEIGHT = 30
CELL_SIZE = 20
SIDEBAR_WIDTH = 220
WINDOW_WIDTH = GRID_WIDTH * CELL_SIZE + SIDEBAR_WIDTH
WINDOW_HEIGHT = GRID_HEIGHT * CELL_SIZE
FPS = 60

# --- é¢œè‰²å®šä¹‰ ---
COLOR_BG = (30, 30, 30)
COLOR_GRID_LINE = (50, 50, 50)  # ç½‘æ ¼çº¿é¢œè‰²
COLOR_EMPTY = (240, 240, 240)
COLOR_TREE = (34, 139, 34)
COLOR_FIRE = (255, 69, 0)
COLOR_BURNT = (50, 50, 50)
COLOR_WALL = (100, 100, 100)
COLOR_EXTINGUISHED = (100, 149, 237)
COLOR_UAV = (0, 191, 255)
COLOR_UGV = (255, 215, 0)
COLOR_SUPPORT = (255, 105, 180) # æ•‘æ´æœºå™¨äººï¼šç²‰çº¢è‰²
COLOR_DEPOT = (138, 43, 226)

# --- ä»¿çœŸå‚æ•° ---
FIRE_SPREAD_PROB = 0.05
TREE_DENSITY = 0.7
TREE_MAX_FUEL = 100
WIND_STRENGTH = 2.5
DRYNESS_INCREASE_RATE = 1.5
IGNITION_DRYNESS_THRESHOLD = 100
SPONTANEOUS_FIRE_PROB = 0.0001

# --- æœºå™¨äººå‚æ•° ---
ROBOT_MAX_BATTERY = 200
ROBOT_MAX_WATER = 30
ROBOT_WATER_RESERVE = 5          # æ­¦è£…è¿”èˆªé¢„ç•™æ°´é‡
ROBOT_LOW_BATTERY_THRESHOLD = 40
ROBOT_IDLE_RETURN_THRESHOLD = 100
STATUS_BAR_WIDTH = 18
STATUS_BAR_HEIGHT = 3

# --- ML & GA å‚æ•° ---
ML_LEARNING_RATE = 0.05
BID_REJECT_THRESHOLD = 5000
PREDICTION_PENALTY = 2500.0       # ç”± GA åŠ¨æ€è°ƒèŠ‚
GA_EVOLVE_INTERVAL = 200        # æ¯ 1000 å¸§è¿›åŒ–ä¸€æ¬¡


================================================
FILE: core/genetic_optimizer.py
================================================
# core/genetic_optimizer.py
import random
import numpy as np


class Genome:
    def __init__(self, penalty=None, radius=None):
        # åŸºå›  1: æ‹¥æŒ¤æƒ©ç½šæƒé‡ (0 ~ 1000)
        self.penalty = penalty if penalty is not None else random.uniform(1000, 4000)
        # åŸºå›  2: æ‹¥æŒ¤åŠå¾„ (1 ~ 8)
        self.radius = radius if radius is not None else random.randint(2, 6)

        # é€‚åº”åº¦ç»Ÿè®¡
        self.fitness = 0
        self.extinguished_count = 0
        self.severity_bonus = 0      # [æ–°å¢] ç­å¤§ç«çš„é¢å¤–å¥–åŠ±
        self.stranded_count = 0      # [æ–°å¢] ææµ…æ¬¡æ•°æƒ©ç½š
        self.crowded_frames = 0  # è®°å½•å‘ç”Ÿæ‹¥æŒ¤çš„å¸§æ•°
        self.idle_frames = 0  # [æ–°å¢] è®°å½•é—²ç½®æ€»å¸§æ•°

    def mutate(self, rate=0.1):
        """éšæœºå˜å¼‚"""
        if random.random() < rate:
            self.penalty += random.uniform(-500, 500)
            self.penalty = max(0, min(4000, self.penalty))
        if random.random() < rate:
            self.radius += random.choice([-1, 1])
            self.radius = max(2, min(4, self.radius))


class GeneticOptimizer:
    def __init__(self, pop_size=4):
        self.pop_size = pop_size
        self.population = [Genome() for _ in range(pop_size)]
        self.current_idx = 0
        self.generation = 1

        # ç¡®ä¿ç§ç¾¤é‡Œæœ‰ä¸€ä¸ªè¾ƒæ¿€è¿›çš„åˆå§‹å€¼ä½œä¸ºç§å­
        self.population[0] = Genome(penalty=2500, radius=5)
    def evaluate_fitness(self, genome):
        """
        é‡æ„è¯„ä»·å‡½æ•°ï¼š
        Score = (åŸºç¡€ç­ç« * 10) + (ç«åœºå¼ºåº¦å¥– * 5) - (ææµ…æƒ©ç½š * 100) - (æ‹¥æŒ¤æƒ©ç½š * 10)
        """
        score = (genome.extinguished_count * 15.0) + \
                (genome.severity_bonus * 5.0) - \
                (genome.stranded_count * 150.0) - \
                (genome.crowded_frames * 10.0) - \
                (genome.idle_frames * 8.0)
        
        genome.fitness = max(1, score) # ç¡®ä¿åˆ†æ•°ä¸ºæ­£
        return genome.fitness

    def get_current_genome(self):
        """è·å–å½“å‰åŸºå› ç»„"""
        return self.population[self.current_idx]

    def record_success(self):
        """è®°å½•ä¸€æ¬¡æˆåŠŸç­ç«"""
        self.population[self.current_idx].extinguished_count += 1

    def record_crowding(self):
        """è®°å½•ä¸€æ¬¡æ‹¥æŒ¤äº‹ä»¶"""
        self.population[self.current_idx].crowded_frames += 1

    def evaluate_fitness(self, genome):
        """è®¡ç®—é€‚åº”åº¦: ç­ç«å¥–åŠ± - æ‹¥æŒ¤æƒ©ç½š"""
        # é€»è¾‘: æˆ‘ä»¬æƒ³è¦å¤šç­ç«ï¼Œä¸”å°‘æ‰å †
        score = (genome.extinguished_count * 20.0) - (genome.crowded_frames * 15.0)
        genome.fitness = score
        return score

    def next_step(self):
        """åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªä¸ªä½“ï¼Œå¦‚æœä¸€è½®ç»“æŸåˆ™è¿›åŒ–"""
        # 1. ç»“ç®—å½“å‰ä¸ªä½“çš„é€‚åº”åº¦
        current = self.population[self.current_idx]
        self.evaluate_fitness(current)

        # 2. ç§»åŠ¨ç´¢å¼•
        self.current_idx += 1

        # 3. å¦‚æœä¸€ä»£è·‘å®Œäº†ï¼Œè¿›è¡Œè¿›åŒ–
        if self.current_idx >= self.pop_size:
            self.evolve()
            self.current_idx = 0
            self.generation += 1
            return True  # è¡¨ç¤ºå¼€å¯äº†æ–°çš„ä¸€ä»£
        return False

    def evolve(self):
        """è¿›åŒ–é€»è¾‘: ç²¾è‹±ä¿ç•™ + å˜å¼‚"""
        # æŒ‰é€‚åº”åº¦æ’åº (é«˜çš„åœ¨å‰)
        self.population.sort(key=lambda g: g.fitness, reverse=True)

        best = self.population[0]
        print(f"--- Generation {self.generation} Complete ---")
        print(
            f"Best Genome: Penalty={best.penalty:.1f}, Radius={best.radius}, Score={best.fitness:.1f}"
        )

        # ç²¾è‹±ç­–ç•¥: ä¿ç•™æœ€å¥½çš„ 1 ä¸ªï¼Œå‰©ä¸‹çš„ç”±å®ƒå˜å¼‚äº§ç”Ÿ
        new_pop = [best]  # ä¿ç•™å† å†›

        while len(new_pop) < self.pop_size:
            # å¤åˆ¶å† å†›å¹¶å˜å¼‚
            child = Genome(best.penalty, best.radius)
            child.mutate(rate=0.5)  # è¾ƒé«˜çš„å˜å¼‚ç‡ä»¥æ¢ç´¢
            # é‡ç½®ç»Ÿè®¡æ•°æ®
            child.extinguished_count = 0
            child.crowded_frames = 0
            new_pop.append(child)

        # é‡ç½®å† å†›çš„ç»Ÿè®¡æ•°æ®ä»¥ä¾¿ä¸‹ä¸€è½®æµ‹è¯•
        best.extinguished_count = 0
        best.crowded_frames = 0

        self.population = new_pop



================================================
FILE: core/grid_map.py
================================================
import numpy as np
import random
from configs.settings import *


class GridMap:
    WIND_DATA = [
        ("N", (0, -1)),
        ("S", (0, 1)),
        ("W", (-1, 0)),
        ("E", (1, 0)),
        ("NW", (-1, -1)),
        ("NE", (1, -1)),
        ("SW", (-1, 1)),
        ("SE", (1, 1)),
    ]

    def __init__(self, width=GRID_WIDTH, height=GRID_HEIGHT):
        self.width = width
        self.height = height
        self.grid = np.zeros((width, height), dtype=int)
        self.fuel_grid = np.zeros((width, height), dtype=int)
        self.last_scan_frame = np.zeros((width, height), dtype=int) # è®°å½•æ— äººæœºæ‰«æåŠå¾„å†…çš„ç´§è¿«åº¦
        self.dryness_grid = np.zeros((width, height), dtype=float)
        self.wind_name, self.wind_direction = random.choice(self.WIND_DATA)
        self.depots = []  # [æ–°å¢] è¡¥ç»™ç«™ç´¢å¼•
        print(
            f"Simulation Init: Wind is blowing {self.wind_name} {self.wind_direction}"
        )
        self.generate_forest()

    def generate_forest(self, density=TREE_DENSITY):
        self.fuel_grid.fill(0)
        for x in range(self.width):
            for y in range(self.height):
                rand = random.random()
                if rand < density:
                    self.grid[x][y] = 1
                    self.fuel_grid[x][y] = TREE_MAX_FUEL
                    self.dryness_grid[x][y] = random.uniform(
                        0, IGNITION_DRYNESS_THRESHOLD * 0.5
                    )
                elif rand < density + 0.05:
                    self.grid[x][y] = 3
                else:
                    self.grid[x][y] = 0
        depot_coords = [
            (0, 0),
            (self.width - 1, 0),
            (0, self.height - 1),
            (self.width - 1, self.height - 1),
        ]
        for dx, dy in depot_coords:
            self.grid[dx][dy] = 5
            self.fuel_grid[dx][dy] = 0
            self.depots.append((dx, dy))  # [æ¸…å•2] è®°å½•åæ ‡

    # [æ¸…å•3] å‘é‡åŒ–æ›´æ–°
    def update_dryness(self):
        tree_mask = self.grid == 1 # æ ‘æœ¨æ©ç 
        noise = np.random.uniform(0.5, 1.5, size=(self.width, self.height)) # éšæœºå™ªå£°
        self.dryness_grid[tree_mask] += DRYNESS_INCREASE_RATE * noise[tree_mask] # å¢åŠ å¹²ç‡¥åº¦

        ignite_mask = tree_mask & (self.dryness_grid > IGNITION_DRYNESS_THRESHOLD) # ç‚¹ç‡ƒæ©ç 
        # éå†ç‚¹ç‡ƒæ©ç å†…çš„åŒºåŸŸï¼Œå¦‚æœåŒºåŸŸå†…çš„å¹²ç‡¥åº¦å¤§äºç‚¹ç‡ƒå¹²ç‡¥åº¦é˜ˆå€¼ï¼Œä¸”éšæœºæ•°å°äºç‚¹ç‡ƒæ¦‚ç‡ï¼Œåˆ™ç‚¹ç‡ƒæ ‘æœ¨
        for x, y in np.argwhere(
            ignite_mask
            & (np.random.random((self.width, self.height)) < SPONTANEOUS_FIRE_PROB)
        ):
            self.grid[x][y] = 2
            self.dryness_grid[x][y] = 0
            print(f"Spontaneous ignition at ({x}, {y})!")

    # [æ¸…å•3] å‘é‡åŒ–æ ¸å¿ƒ
    def update_fire_spread(self):
        self.update_dryness() # æ›´æ–°å¹²ç‡¥åº¦
        new_grid = self.grid.copy()
        fire_mask = self.grid == 2
        self.fuel_grid[fire_mask] -= 1 # å·²ç‚¹ç‡ƒæ ‘æœ¨ç‡ƒæ–™å‡å°‘1
        new_grid[fire_mask & (self.fuel_grid <= 0)] = 4 # å·²ç‚¹ç‡ƒæ ‘æœ¨ç‡ƒæ–™å‡å°‘åˆ°0ï¼Œåˆ™æ ‡è®°ä¸ºå·²ç†„ç­

        fire_indices = np.argwhere(self.grid == 2) # å·²ç‚¹ç‡ƒæ ‘æœ¨ç´¢å¼•
        for fx, fy in fire_indices:
            for dx in [-1, 0, 1]:
                for dy in [-1, 0, 1]:
                    if dx == 0 and dy == 0:
                        continue
                    nx, ny = fx + dx, fy + dy
                    if (
                        0 <= nx < self.width
                        and 0 <= ny < self.height
                        and self.grid[nx][ny] == 1
                    ):
                        # è®¡ç®—é£å‘ä¸ç«ç„°ä¼ æ’­æ–¹å‘çš„ç‚¹ç§¯
                        dot_prod = (
                            dx * self.wind_direction[0] + dy * self.wind_direction[1]
                        )
                        factor = 1.0 + (dot_prod * WIND_STRENGTH)
                        if random.random() < FIRE_SPREAD_PROB * max(0, factor):
                            new_grid[nx][ny] = 2
                            self.dryness_grid[nx][ny] = 0
        self.grid = new_grid

    # --- ä»¥ä¸‹å®Œå…¨ä¿æŒåŸå§‹é€»è¾‘ä¸æ ¼å¼ ---
    def ignite_random(self):
        """éšæœºç‚¹ç‡ƒä¸€æ£µæ ‘"""
        trees = np.argwhere(self.grid == 1)
        if len(trees) > 0:
            idx = random.randint(0, len(trees) - 1)
            x, y = trees[idx]
            self.grid[x][y] = 2  # ç‚¹ç‡ƒæ ‘æœ¨
            self.dryness_grid[x][y] = 0  # åˆå§‹å¹²ç‡¥åº¦
            print(f"Fire started at ({x}, {y})")
            return (x, y)
        return None

    def get_state(self, x, y):
        """è·å–ç½‘æ ¼å•å…ƒæ ¼çŠ¶æ€"""
        if 0 <= x < self.width and 0 <= y < self.height:
            return self.grid[x][y] # è¿”å›ç½‘æ ¼å•å…ƒæ ¼çŠ¶æ€
        return 3 # è¿”å›éšœç¢ç‰©çŠ¶æ€

    def set_state(self, x, y, state):
        if 0 <= x < self.width and 0 <= y < self.height:
            self.grid[x][y] = state
            if state == 4 or state == 2:
                self.dryness_grid[x][y] = random.uniform(0, 5)

    def mark_scanned(self, cx, cy, radius, frame_id):
        """æ ‡è®°æœ€åä¸€æ¬¡æ‰«æè¯¥åŒºåŸŸçš„æ—¶é—´"""
        x_min, x_max = max(0, cx - radius), min(self.width, cx + radius + 1)
        y_min, y_max = max(0, cy - radius), min(self.height, cy + radius + 1)
        self.last_scan_frame[x_min:x_max, y_min:y_max] = frame_id
    
    def get_average_urgency(self, cx, cy, radius, frame_id):
        """è·å–æ— äººæœºæ‰«æåŠå¾„å†…çš„å¹³å‡ç´§è¿«åº¦"""
        x_min, x_max = max(0, cx - radius), min(self.width, cx + radius + 1) # è®¡ç®—xåæ ‡èŒƒå›´ï¼Œå…·æœ‰é˜²è¶Šç•Œå¤„ç†
        y_min, y_max = max(0, cy - radius), min(self.height, cy + radius + 1) # è®¡ç®—yåæ ‡èŒƒå›´
        return np.mean(frame_id - self.last_scan_frame[x_min:x_max, y_min:y_max]) # è®¡ç®—å¹³å‡ç´§è¿«åº¦=è¯¥åŒºåŸŸï¼ˆå½“å‰å¸§æ•°-ä¸Šæ¬¡æ‰«æå¸§æ•°ï¼‰çš„å¹³å‡å€¼    




================================================
FILE: core/pathfinding.py
================================================
import heapq

# Node ç±»ä¿æŒä¸å˜
class Node:
    def __init__(self, parent=None, position=None):
        self.parent = parent
        self.position = position
        self.g = 0
        self.h = 0
        self.f = 0

    def __eq__(self, other):
        return self.position == other.position

    def __lt__(self, other):
        return self.f < other.f

def astar(grid_map, start, end, has_water=True):
    # 1. ç»ˆç‚¹å¦‚æœæ˜¯å¢™ï¼Œç›´æ¥è¿”å›ä¸å¯è¾¾
    if grid_map.get_state(end[0], end[1]) == 3:
        return None

    start_node = Node(None, start)
    end_node = Node(None, end)

    open_list = []
    heapq.heappush(open_list, start_node)
    
    # [ä¼˜åŒ– 1] ä½¿ç”¨ g_costs å­—å…¸ä»£æ›¿ closed_set
    # é”®æ˜¯åæ ‡ (x,y)ï¼Œå€¼æ˜¯åˆ°è¾¾è¯¥ç‚¹çš„æœ€å° G å€¼ (ä»£ä»·)
    # ä½œç”¨ï¼šæ—¢èƒ½å……å½“ visited é›†åˆï¼Œåˆèƒ½è¿›è¡Œâ€œæ›´ä¼˜è·¯å¾„å‰ªæâ€
    g_costs = {start: 0} 

    while len(open_list) > 0:
        current_node = heapq.heappop(open_list)
        current_pos = current_node.position

        # [ä¼˜åŒ– 2] å»¶è¿Ÿåˆ é™¤ (Lazy Deletion)
        # å¦‚æœå½“å‰å–å‡ºçš„èŠ‚ç‚¹ä»£ä»·æ¯”æˆ‘ä»¬è®°å½•çš„æœ€å°ä»£ä»·è¿˜è¦å¤§ï¼Œè¯´æ˜è¿™æ˜¯ä¸ªâ€œè¿‡æ—¶â€çš„åƒåœ¾èŠ‚ç‚¹ï¼Œç›´æ¥è·³è¿‡
        if current_node.g > g_costs.get(current_pos, float('inf')):
            continue

        # æ‰¾åˆ°ç»ˆç‚¹
        if current_node == end_node:
            path = []
            while current_node is not None:
                path.append(current_node.position)
                current_node = current_node.parent
            return path[::-1]

        # éå†é‚»å±…
        for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0)]:
            nx, ny = (
                current_pos[0] + new_position[0],
                current_pos[1] + new_position[1],
            )

            # --- åŸºç¡€æ£€æŸ¥ ---
            # 1. è¾¹ç•Œæ£€æŸ¥
            if not (0 <= nx < grid_map.width and 0 <= ny < grid_map.height):
                continue
            # 2. éšœç¢ç‰©æ£€æŸ¥
            cell_val = grid_map.get_state(nx, ny)
            if cell_val == 3:
                continue

            # --- ä»£ä»·è®¡ç®— ---
            move_cost = 1
            if cell_val == 2:
                move_cost = 1 if has_water else 50
            
            new_g = current_node.g + move_cost

            # --- [æ ¸å¿ƒä¼˜åŒ–é€»è¾‘] ---
            # åªæœ‰å½“æˆ‘ä»¬æ‰¾åˆ°äº†ä¸€æ¡é€šå¾€ (nx, ny) çš„æ›´çŸ­è·¯å¾„æ—¶ï¼Œæ‰å¤„ç†å®ƒ
            # å¦‚æœæˆ‘ä»¬ä¹‹å‰å·²ç»ç”¨æ›´å°‘çš„ä»£ä»·åˆ°è¾¾è¿‡è¿™é‡Œï¼Œå°±ä¸è¦å†æŠŠè¿™ä¸ªé‚»å±…åŠ å…¥é˜Ÿåˆ—äº†
            if (nx, ny) not in g_costs or new_g < g_costs[(nx, ny)]:
                # æ›´æ–°è®°åˆ†æ¿
                g_costs[(nx, ny)] = new_g
                
                # åˆ›å»ºæ–°èŠ‚ç‚¹å¹¶åŠ å…¥é˜Ÿåˆ—
                new_node = Node(current_node, (nx, ny))
                new_node.g = new_g
                new_node.h = abs(nx - end[0]) + abs(ny - end[1])
                new_node.f = new_node.g + new_node.h
                heapq.heappush(open_list, new_node)

    return None


================================================
FILE: core/predictor.py
================================================
import numpy as np
import math


class EfficiencyPredictor:
    def __init__(self, learning_rate=0.1):
        self.lr = learning_rate
        self.base_lr = learning_rate

        # [æ ¸å¿ƒä¿®å¤] ä¸è¦ç”¨ np.zeros åˆå§‹åŒ–
        # æˆ‘ä»¬è¦ç»™æœºå™¨äººæ¤å…¥â€œå¸¸è¯†â€ (Heuristic Initialization)
        # æƒé‡å¯¹åº”é¡ºåº: [è·ç¦»æ¥è¿‘åº¦, ç«åŠ¿ä¸¥é‡åº¦, ç”µé‡, æ°´é‡, éšœç¢å¯†åº¦, Bias]

        self.weights = np.array([
            0.5,   # W_Prox (+): ç¦»å¾—è¶Šè¿‘è¶Šå¥½ (ç‰¹å¾æ˜¯ 1-distï¼Œæ‰€ä»¥è¦æ­£æƒé‡)
            0.5,   # W_Sev  (+): ç«å¤§æ¯”è¾ƒå€¼å¾—å» (æ”¶ç›Šé«˜)
            0.5,   # W_Bat  (+): ç”µå¤šå¥½
            0.5,   # W_Wat  (+): æ°´å¤šå¥½
            -0.5,  # W_Obs  (-): éšœç¢ç‰©å¤šä¸å¥½ (è´Ÿæƒé‡)
            -0.3,  # W_Wind
            1.0    # Bias   (+): æ€»ä½“ä¿æŒä¹è§‚
        ])

        self.training_count = 0

    # ... ä¸‹é¢çš„ sigmoid, predict_prob, train æ–¹æ³•ä¿æŒä¸å˜ ...
    def sigmoid(self, x):
        return 1 / (1 + np.exp(-np.clip(x, -20, 20)))

    def predict_prob(self, features):
        x = np.append(features, 1.0)
        return self.sigmoid(np.dot(self.weights, x))

    def train(self, features, label):
        x = np.append(features, 1.0)
        pred = self.sigmoid(np.dot(self.weights, x))

        # å­¦ä¹ ç‡è¡°å‡
        current_lr = max(0.01, self.base_lr * (0.9995 ** self.training_count))

        error = pred - label
        self.weights -= current_lr * error * x

        # æƒé‡é™åˆ¶
        self.weights = np.clip(self.weights, -10.0, 10.0)
        self.weights[0] = max(0.4, self.weights[0]) # W_Prox è‡³å°‘ä¸ºæ­£
        self.weights[1] = max(0.1, self.weights[1]) # W_Sev è‡³å°‘ä¸ºæ­£
        self.weights[2] = max(0.3, self.weights[2]) # W_Bat
        self.weights[3] = max(0.3, self.weights[3]) # W_Wat
        self.weights[5] = min(-0.2, self.weights[5]) # å¼ºåˆ¶é£å‘æƒé‡è‡³å°‘æ˜¯ -0.2
        self.training_count += 1
        print(f"[Learn] Label:{label} Pred:{pred:.2f} -> NewWeights:{np.round(self.weights, 3)}")

